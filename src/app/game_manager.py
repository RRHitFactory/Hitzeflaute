from typing import Protocol, runtime_checkable

from src.app.game_repo.base import BaseGameStateRepo
from src.engine.new_game import DefaultInitializer
from src.models.game_settings import GameSettings
from src.models.game_state import GameState
from src.models.ids import GameId
from src.models.message import GameToPlayerMessage, PlayerToGameMessage, ToGameMessage, InternalMessage, FromGameMessage


@runtime_checkable
class CanReceiveGameToPlayerMessages(Protocol):
    # A generic stub for the front end implementation
    def handle_player_messages(self, msgs: list[GameToPlayerMessage]) -> None: ...


@runtime_checkable
class CanReceiveToGameMessage(Protocol):
    # A generic stub for the game engine implementation
    @classmethod
    def handle_message(cls, game_state: GameState, msg: ToGameMessage) -> tuple[GameState, list[FromGameMessage]]: ...


class GameManager:
    def __init__(
        self,
        game_repo: BaseGameStateRepo,
        game_engine: CanReceiveToGameMessage,
        front_end: CanReceiveGameToPlayerMessages,
    ) -> None:
        assert isinstance(game_repo, BaseGameStateRepo)
        assert isinstance(game_engine, CanReceiveToGameMessage)
        assert isinstance(front_end, CanReceiveGameToPlayerMessages)
        self.game_repo = game_repo
        self.game_engine = game_engine
        self.front_end = front_end

    def new_game(self, player_names: list[str]) -> GameId:
        game_id = self.game_repo.generate_game_id()
        settings = GameSettings()
        game_initializer = DefaultInitializer(settings=settings)
        new_game_state = game_initializer.create_new_game(game_id=game_id, player_names=player_names)
        self.game_repo.add_game_state(game=new_game_state)
        return game_id

    def handle_player_message(self, game_id: GameId, msg: PlayerToGameMessage) -> None:
        # TODO Make this atomic
        game_state = self.game_repo.get_game_state(game_id)
        updated_game_state = self._handle_message(game_state=game_state, msg=msg)
        self.game_repo.update_game_state(updated_game_state)

    def _handle_message(self, game_state: GameState, msg: ToGameMessage) -> GameState:
        game_state, messages = self.game_engine.handle_message(game_state=game_state, msg=msg)

        msgs_to_players = [e for e in messages if isinstance(e, GameToPlayerMessage)]
        self.front_end.handle_player_messages(msgs=msgs_to_players)

        msgs_to_self = [e for e in messages if isinstance(e, InternalMessage)]
        if not len(msgs_to_self):
            return game_state

        assert len(msgs_to_self) == 1, "There should be at most one internal message generated by the engine."
        return self._handle_message(game_state=game_state, msg=msgs_to_self[0])
