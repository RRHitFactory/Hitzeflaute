from typing import Protocol, runtime_checkable

from src.app.game_repo.base import BaseGameRepo
from src.models.game_state import GameState
from src.models.ids import GameId
from src.models.message import GameToPlayerMessage, PlayerToGameMessage, ToGameMessage, InternalMessage, FromGameMessage


@runtime_checkable
class CanReceiveGameToPlayerMessages(Protocol):
    # A generic stub for the front end implementation
    def handle_player_messages(self, msgs: list[GameToPlayerMessage]) -> None:
        ...


@runtime_checkable
class CanReceiveToGameMessage(Protocol):
    # A generic stub for the game engine implementation
    @classmethod
    def handle_message(cls, game_state: GameState, msg: ToGameMessage) -> tuple[GameState, list[FromGameMessage]]:
        ...


class GameManager:
    def __init__(
            self,
            game_repo: BaseGameRepo,
            game_engine: CanReceiveToGameMessage,
            front_end: CanReceiveGameToPlayerMessages
    ) -> None:
        assert isinstance(game_repo, BaseGameRepo)
        assert isinstance(game_engine, CanReceiveToGameMessage)
        assert isinstance(front_end, CanReceiveGameToPlayerMessages)
        self.game_repo = game_repo
        self.game_engine = game_engine
        self.front_end = front_end

    def handle_player_message(self, game_id: GameId, msg: PlayerToGameMessage) -> None:
        # TODO Make this atomic
        game_state = self.game_repo.get_game(game_id)
        updated_game_state = self.handle_message(game_state=game_state, msg=msg)
        self.game_repo.update_game(updated_game_state)

    def handle_message(self, game_state: GameState, msg: ToGameMessage) -> GameState:
        game_state, messages = self.game_engine.handle_message(game_state=game_state, msg=msg)

        msgs_to_players = [e for e in messages if isinstance(e, GameToPlayerMessage)]
        self.front_end.handle_player_messages(msgs=msgs_to_players)

        msgs_to_self = [e for e in messages if isinstance(e, InternalMessage)]
        if not len(msgs_to_self):
            return game_state

        assert len(msgs_to_self) == 1, "There should be at most one internal message generated by the engine."
        return self.handle_message(game_state=game_state, msg=msgs_to_self[0])
