from typing import Protocol, runtime_checkable

from src.app.game_repo.base import BaseGameStateRepo
from src.engine.new_game import DefaultGameInitializer
from src.models.game_settings import GameSettings
from src.models.game_state import GameState
from src.models.ids import GameId
from src.models.message import (
    GameToPlayerMessage,
    PlayerToGameMessage,
    ToGameMessage,
    InternalMessage,
    FromGameMessage,
    GameUpdate,
)


@runtime_checkable
class CanReceiveGameToPlayerMessages(Protocol):
    # A generic stub for the front end implementation
    def handle_player_messages(self, msgs: list[GameToPlayerMessage]) -> None: ...


@runtime_checkable
class CanReceiveToGameMessage(Protocol):
    # A generic stub for the game engine implementation
    @classmethod
    def handle_message(cls, game_state: GameState, msg: ToGameMessage) -> tuple[GameState, list[FromGameMessage]]: ...


class GameManager:
    def __init__(
        self,
        game_repo: BaseGameStateRepo,
        game_engine: CanReceiveToGameMessage,
        front_end: CanReceiveGameToPlayerMessages,
    ) -> None:
        assert isinstance(game_repo, BaseGameStateRepo)
        assert isinstance(game_engine, CanReceiveToGameMessage)
        assert isinstance(front_end, CanReceiveGameToPlayerMessages)
        self.game_repo = game_repo
        self.game_engine = game_engine
        self.front_end = front_end

    def handle_player_message(self, game_id: GameId, msg: PlayerToGameMessage) -> None:
        # TODO Make this atomic
        game_state = self.game_repo.get_game_state(game_id)

        updated_game_state, msgs_to_players = self._handle_message(game_state=game_state, msg=msg)
        ids = game_state.players.human_player_ids
        game_update_messages = [GameUpdate(player_id=p, game_state=updated_game_state, message="") for p in ids]
        msgs_to_players.extend(game_update_messages)

        self.front_end.handle_player_messages(msgs=msgs_to_players)
        self.game_repo.update_game_state(updated_game_state)

    def _handle_message(self, game_state: GameState, msg: ToGameMessage) -> tuple[GameState, list[GameToPlayerMessage]]:
        game_state, messages = self.game_engine.handle_message(game_state=game_state, msg=msg)

        msgs_to_players = [e for e in messages if isinstance(e, GameToPlayerMessage)]
        msgs_to_self = [e for e in messages if isinstance(e, InternalMessage)]

        if not len(msgs_to_self):
            return game_state, msgs_to_players

        assert len(msgs_to_self) == 1, "There should be at most one internal message generated by the engine."

        new_game_state, new_msgs_to_players = self._handle_message(game_state=game_state, msg=msgs_to_self[0])
        msgs_to_players.extend(new_msgs_to_players)
        return new_game_state, msgs_to_players

    @classmethod
    def new_game(cls, game_repo: BaseGameStateRepo, player_names: list[str]) -> GameId:
        game_id = game_repo.generate_game_id()
        settings = GameSettings()
        game_initializer = DefaultGameInitializer(settings=settings)
        new_game_state = game_initializer.create_new_game(game_id=game_id, player_names=player_names)
        game_repo.add_game_state(game=new_game_state)
        return game_id
